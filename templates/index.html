<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>FALCON: Student Challenge</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            width: 90%;
            max-width: 800px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
        }
        
        #prompt {
            padding: 14px;
            width: 100%;
            max-width: 640px;
            font-size: 16px;
            line-height: 1.4;
            border-radius: 6px;
            border: 1px solid #444;
            background: #222;
            color: #fff;
            resize: vertical;
            min-height: 80px;
            white-space: pre-wrap;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #444;
            cursor: not-allowed;
        }
        
        #status {
            color: #fff;
            margin-top: 0.5rem;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            max-width: 100%;
            word-wrap: break-word;
            display: none;
        }
        
        #qr-container {
            margin-top: 1rem;
            padding: 20px;
            background: white;
            border-radius: 8px;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        
        #qr-container h3 {
            margin: 0;
            color: #333;
        }
        
        .qr-image {
            max-width: 300px;
            max-height: 300px;
            border: 2px solid #ddd;
            padding: 10px;
            background: white;
            margin: 10px;
        }
        
        .qr-images-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
        }
        
        .download-link {
            color: #007bff;
            text-decoration: none;
            padding: 5px 10px;
            border: 1px solid #007bff;
            border-radius: 4px;
            transition: background 0.3s;
        }
        
        .download-link:hover {
            background: #007bff;
            color: white;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: none;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Small phones */
        @media (max-width: 480px) {
            .container {
                width: 95%;
                gap: 0.75rem;
            }
            .controls {
                gap: 0.75rem;
            }
            #prompt {
                max-width: 100%;
                font-size: 18px; /* larger, more readable */
                padding: 16px;
                min-height: 100px;
            }
            button {
                width: 100%;
                font-size: 18px;
                padding: 14px 18px; /* touch friendly */
            }
            .presets .preset-btn {
                flex: 1 1 45%;
            }
        }

        /* Tablets / small laptops */
        @media (min-width: 481px) and (max-width: 1024px) {
            #prompt {
                max-width: 720px;
                font-size: 17px;
                padding: 16px;
                min-height: 120px;
            }
            button {
                font-size: 17px;
                padding: 12px 20px;
            }
        }

        /* Desktops */
        @media (min-width: 1025px) {
            #prompt {
                max-width: 720px;
                font-size: 18px;
                padding: 18px;
                min-height: 140px;
            }
            button {
                font-size: 17px;
                padding: 12px 22px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        
        
        <div class="controls">
            <div class="presets" id="presets" style="display:flex;gap:0.5rem;flex-wrap:wrap;justify-content:center;width:100%;max-width:800px;">
              <button type="button" class="preset-btn" data-mode="qr" data-id="qr">QR-code</button>
              <button type="button" class="preset-btn" data-mode="gesture" data-id="gesture">Gesture detection</button>
              <button type="button" class="preset-btn" data-mode="object" data-id="object">Object detection</button>
            </div>
            <textarea id="prompt" placeholder="Enter a prompt or choose a preset below..."></textarea>
            <button id="runButton" onclick="runGenerate()">Generate</button>
            <button id="instantRunButton" title="Run with existing QR code (no generation)" style="display:none;">Instant Run</button>
            <!-- <button id="reuseButton" title="Run with existing code (no generation)">Instant Run</button> -->
            <div class="spinner" id="spinner"></div>
        </div>
        
        <div id="status"></div>
        <div id="gesture-presets" class="preset-group" style="display:none;width:100%;max-width:800px;margin-top:6px;"></div>
        <div id="object-presets" class="preset-group" style="display:none;width:100%;max-width:800px;margin-top:6px;"></div>
        <div id="presetList" style="display:none;width:100%;max-width:800px;margin-top:8px;"></div>
        
        <div id="live-container" style="display:none; margin-top:1rem; width:100%; text-align:center;">
          <img id="live-video" src="" alt="Live stream"
              style="max-width:100%; height:auto; border-radius:12px;"/>
          <div style="color:#ccc; margin-top:0.5rem;">Live camera from server</div>
        </div>

        <div id="qr-container">
            <h3>Generated Result</h3>
            <div id="qr-images" class="qr-images-grid"></div>
        </div>
    </div>
    
    <script>
  // -------------------- Presets --------------------

  const PRESETS = {
    qr: {
      mode: 'qr',
      prompt: "I want to verify myself using a QR code."
    },
    gesture: {
      mode: 'gesture',
      prompt: "I want to verify myself with a specific gesture. The gesture is 'thumb up'."
    },
    object: {
      mode: 'object',
      prompt: "I want to verify myself with a specific object. The object is 'apple'."
    }
  };

  const liveContainer = document.getElementById('live-container');
  const liveImg = document.getElementById('live-video');

  let selectedMode = 'qr';
  let currentSessionId = null;
  let lastUserPrompt = '';
  const reuseButton = document.getElementById('reuseButton');

  // -------------------- DOM refs --------------------
  const statusDiv = document.getElementById('status');
  const qrContainer = document.getElementById('qr-container');
  const qrImagesDiv = document.getElementById('qr-images');
  const runButton = document.getElementById('runButton');
  const spinner = document.getElementById('spinner');
  const promptInput = document.getElementById('prompt');
  const instantRunButton = document.getElementById('instantRunButton');
  function toggleInstantRunButton() {
    if (!instantRunButton) return;
    instantRunButton.style.display = (selectedMode === 'qr') ? 'inline-block' : 'none';
  }

  // -------------------- UI helpers --------------------
  function setStatus(text, color = 'rgba(255, 255, 255, 0.1)') {
    statusDiv.style.display = 'block';
    statusDiv.textContent = text;
    statusDiv.style.background = color;
  }

  function clearResults() {
    qrContainer.style.display = 'none';
    qrImagesDiv.innerHTML = '';
    const existing = document.getElementById('verifyButton');
    if (existing) existing.remove();
  }

  function showQrImages(files) {
    if (!files || files.length === 0) return;
    qrContainer.style.display = 'flex';
    files.forEach(filename => {
      const img = document.createElement('img');
      img.src = `/qr-code/${filename}?t=${Date.now()}`;
      img.className = 'qr-image';
      img.alt = 'QR Code';

      const imgContainer = document.createElement('div');
      imgContainer.style.textAlign = 'center';

      const downloadLink = document.createElement('a');
      downloadLink.href = `/qr-code/${filename}`;
      downloadLink.download = filename;
      downloadLink.className = 'download-link';
      downloadLink.textContent = `Download ${filename}`;

      imgContainer.appendChild(img);
      imgContainer.appendChild(document.createElement('br'));
      imgContainer.appendChild(downloadLink);
      qrImagesDiv.appendChild(imgContainer);
    });
  }

  function addVerifyButton(mode) {
    let verifyBtn = document.getElementById('verifyButton');
    if (!verifyBtn) {
      verifyBtn = document.createElement('button');
      verifyBtn.id = 'verifyButton';
      verifyBtn.type = 'button';
      verifyBtn.textContent = 'Verify';
      verifyBtn.style.marginTop = '0.5rem';
      verifyBtn.addEventListener('click', () => runValidate(mode));
      qrContainer.appendChild(verifyBtn);
    }
    verifyBtn.style.display = 'inline-block';
  }

  // -------------------- Mode-specific Presets Group --------------------
  async function loadPresetsGroup(mode) {
  try {
    const res = await fetch('/presets', { cache: 'no-store' });
    const data = await res.json();
    renderPresetGroup(mode, data);
  } catch (e) {
    console.warn('failed to load presets group', mode, e);
  }
}

// Helper for Verify button in reuse path
function addVerifyButtonInstant(mode, script_name=null) {
    let verifyBtn = document.getElementById('verifyButtonReuse');
    if (!verifyBtn) {
      verifyBtn = document.createElement('button');
      verifyBtn.id = 'verifyButtonReuse';
      verifyBtn.type = 'button';
      verifyBtn.textContent = 'Verify (Instant)';
      verifyBtn.style.marginTop = '0.5rem';
      verifyBtn.addEventListener('click', () => runInstantValidate(mode, script_name));
      qrContainer.appendChild(verifyBtn);
    }
    verifyBtn.style.display = 'inline-block';
  }

  function renderPresetGroup(mode, data) {
  const containerId = mode === 'gesture' ? 'gesture-presets' : (mode === 'object' ? 'object-presets' : null);
  if (!containerId) return;
  const container = document.getElementById(containerId);
  if (!container) return;
  container.style.display = 'block';
  container.innerHTML = '';

  const title = document.createElement('h4');
  title.textContent = mode === 'gesture' ? 'Saved gesture presets' : 'Saved object presets';
  title.style.color = '#fff';
  title.style.margin = '6px 0 8px';
  container.appendChild(title);

  const entries = (data && data[mode]) ? Object.entries(data[mode]) : [];
  if (!entries.length) {
    const p = document.createElement('p');
    p.textContent = 'No presets yet';
    p.style.color = '#aaa';
    container.appendChild(p);
    return;
  }

  const list = document.createElement('div');
  list.style.display = 'flex';
  list.style.flexWrap = 'wrap';
  list.style.gap = '8px';

  entries.forEach(([displayName, scriptName]) => {
    const card = document.createElement('div');
    card.style.display = 'flex';
    card.style.alignItems = 'center';
    card.style.gap = '8px';
    card.style.background = 'rgba(255,255,255,0.06)';
    card.style.borderRadius = '8px';
    card.style.padding = '8px 10px';

    const label = document.createElement('span');
    label.textContent = `${displayName}`;
    label.style.color = '#ddd';

    const btn = document.createElement('button');
    btn.textContent = 'Instant Run';
    btn.className = 'btn-secondary';
    btn.onclick = async () => {
      selectedMode = mode;
      clearResults();
      setStatus('Using preset...', 'rgba(255,255,255,0.1)');
      // Initialize via /reuse generate (instant path)
      const genRes = await fetch('/instant-run', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          mode: selectedMode,
          action: 'generate',
          displayName: displayName,
          scriptName: scriptName,
      })
      });
      const genData = await genRes.json();
      if (!genRes.ok) {
        setStatus('Error: ' + (genData.error || 'Failed to initialize'), 'rgba(255,0,0,0.2)');
        return;
      }
      const streamUrl = (genData.stream_url || '/video_feed') + `?t=${Date.now()}`;
      liveImg.src = streamUrl;
      liveContainer.style.display = 'block';
      await runInstantValidate(selectedMode, genData.data.script_name);
    };

    card.appendChild(label);
    card.appendChild(btn);
    list.appendChild(card);
  });

  container.appendChild(list);
}

  // Instant run/validate path
  async function runInstantValidate(mode, scriptName = null) {
    try {
      console.log('Instant validate', mode);
      setStatus('Validating (instant)...', 'rgba(255,255,255,0.1)');
      const res = await fetch('/instant-run', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ mode, action: 'validate', scriptName: scriptName})
      });
      if (res.status === 202) {
        const { job_id, poll_url } = await res.json();
        if (window.__jobPoll) clearInterval(window.__jobPoll);
        window.__jobPoll = setInterval(async () => {
          try {
            const r = await fetch(poll_url, { cache: 'no-store' });
            const s = await r.json();
            setStatus(`Phase: ${s.phase || 'unknown'}`, 'rgba(255,255,255,0.08)');
            if (s.phase === 'ready') {
              const existingInstruction = document.getElementById('live-instruction');
              if (existingInstruction) existingInstruction.remove();
              const instruction = document.createElement('p');
              instruction.id = 'live-instruction';
              instruction.style.color = '#fff';
              instruction.style.marginTop = '0.5rem';
              instruction.textContent = mode === 'gesture' ? 'Start your gesture in front of the camera...' : (mode === 'object' ? 'Show the object to the camera...' : 'Scanning...');
              statusDiv.insertAdjacentElement('afterend', instruction);
            }
            if (s.phase === 'detected' || s.phase === 'done' || s.phase === 'error') {
              clearInterval(window.__jobPoll);
              if (s.data) {
                const pre = document.createElement('pre');
                pre.style.color = '#ddd';
                pre.style.background = 'rgba(255,255,255,0.06)';
                pre.style.padding = '8px';
                pre.style.borderRadius = '6px';
                pre.textContent = JSON.stringify(s.data, null, 2);
                statusDiv.insertAdjacentElement('afterend', pre);
              }
              // Refresh presets when job is done (new verified may be registered)
              loadPresets();
              if (selectedMode === 'gesture') { loadPresetsGroup('gesture'); }
              if (selectedMode === 'object') { loadPresetsGroup('object'); }

              if (s.phase === 'error') {
                setStatus('Error: detection failed.', 'rgba(255,0,0,0.25)');
              } else if (s.phase === 'done') {
                const verified = (s.data && typeof s.data.verified !== 'undefined') ? s.data.verified : (s.verified || false);
                if (verified) {
                  setStatus('Verified!', 'rgba(0,255,0,0.25)');
                } else {
                  setStatus('Verification failed.', 'rgba(255,0,0,0.25)');
                }
              } else {
                setStatus('Detected!', 'rgba(0,255,0,0.2)');
              }
            }
          } catch (err) { console.error('reuse poll error', err); }
        }, 1000);
      } else {
        const data = await res.json();
        setStatus('Error: ' + (data.error || 'Unexpected response'), 'rgba(255,0,0,0.2)');
      }
    } catch (e) {
      setStatus('Error: ' + e.message, 'rgba(255,0,0,0.2)');
    }
  }

  // if (reuseButton) {
  //   reuseButton.addEventListener('click', async () => {
  //     const prompt = promptInput.value.trim();
  //     lastUserPrompt = prompt;
  //     if (!prompt) {
  //       setStatus('Please enter a prompt or choose a preset', 'rgba(255,0,0,0.2)');
  //       return;
  //     }
  //     clearResults();
  //     setStatus('Using existing code...', 'rgba(255,255,255,0.1)');
  //     // Initialize via /reuse generate
  //     const genRes = await fetch('/instant-run', {
  //       method: 'POST',
  //       headers: { 'Content-Type': 'application/json' },
  //       body: JSON.stringify({ mode: selectedMode, action: 'generate', prompt })
  //     });
  //     const genData = await genRes.json();
  //     if (!genRes.ok) {
  //       setStatus('Error: ' + (genData.error || 'Failed to initialize'), 'rgba(255,0,0,0.2)');
  //       return;
  //     }
  //     // Show live feed always
  //     const streamUrl = (genData.stream_url || '/video_feed') + `?t=${Date.now()}`;
  //     liveImg.src = streamUrl;
  //     liveContainer.style.display = 'block';
  //     if (selectedMode === 'qr') {
  //       const files = (genData.data && genData.data.qr_codes) ? genData.data.qr_codes : [];
  //       if (files.length) { showQrImages(files); addVerifyButtonInstant(selectedMode); }
  //       if (genData.data && genData.data.text) {
  //         const p = document.createElement('p');
  //         p.style.color = '#fff';
  //         p.textContent = genData.data.text;
  //         statusDiv.insertAdjacentElement('afterend', p);
  //       }
  //       setStatus('QR ready. Click Verify (Instant).', 'rgba(0,255,0,0.2)');
  //       return;
  //     }
  //     await runInstantValidate(selectedMode);
  //   });
  // }

  // Preset registry UI
  async function loadPresets() {
    try {
      const res = await fetch('/presets', { cache: 'no-store' });
      const data = await res.json();
      renderPresetList(data);
    } catch (e) {
      console.warn('failed to load presets', e);
    }
  }

  function renderPresetList(data) {
    const container = document.getElementById('presetList');
    if (!container) return;
    container.innerHTML = '';
    const groups = [
      { key: 'gesture', title: 'Available Gestures' },
      { key: 'object', title: 'Available Objects' }
    ];
    groups.forEach(g => {
      const entries = (data && data[g.key]) ? Object.entries(data[g.key]) : [];
      const section = document.createElement('div');
      const h = document.createElement('h4');
      h.textContent = g.title;
      h.style.color = '#fff';
      h.style.margin = '8px 0 4px';
      section.appendChild(h);
      if (!entries.length) {
        const p = document.createElement('p');
        p.textContent = 'No presets yet';
        p.style.color = '#aaa';
        section.appendChild(p);
      } else {
        entries.forEach(([displayName, scriptName]) => {
          const row = document.createElement('div');
          row.style.display = 'flex';
          row.style.alignItems = 'center';
          row.style.gap = '8px';
          row.style.marginBottom = '6px';
          const label = document.createElement('span');
          label.textContent = `${displayName} (${scriptName})`;
          label.style.color = '#ddd';
          const btn = document.createElement('button');
          btn.textContent = 'Instant Run';
          btn.className = 'btn-secondary';
          btn.onclick = async () => {
            selectedMode = g.key;
            const phrase = g.key === 'gesture'
              ? `I want to verify myself with a specific gesture. The gesture is '${displayName}'.`
              : `I want to verify myself with a specific object. The object is '${displayName}'.`;
            promptInput.value = phrase;
            lastUserPrompt = phrase;
            clearResults();
            setStatus('Using preset...', 'rgba(255,255,255,0.1)');
            const genRes = await fetch('/instant-run', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ mode: selectedMode, action: 'generate', prompt: phrase })
            });
            const genData = await genRes.json();
            if (!genRes.ok) {
              setStatus('Error: ' + (genData.error || 'Failed to initialize'), 'rgba(255,0,0,0.2)');
              return;
            }
            const streamUrl = (genData.stream_url || '/video_feed') + `?t=${Date.now()}`;
            liveImg.src = streamUrl;
            liveContainer.style.display = 'block';
            if (selectedMode === 'qr') {
              const files = (genData.data && genData.data.qr_codes) ? genData.data.qr_codes : [];
              if (files.length) { showQrImages(files); addVerifyButtonInstant(selectedMode, genData.data.script_name); }
            }
            await runInstantValidate(selectedMode, genData.data.script_name);
          };
          row.appendChild(label);
          row.appendChild(btn);
          section.appendChild(row);
        });
      }
      container.appendChild(section);
    });
  }

  // -------------------- Preset wiring --------------------
  document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const id = btn.getAttribute('data-id');
      const preset = PRESETS[id];
      if (!preset) return;
      selectedMode = preset.mode;
      promptInput.value = preset.prompt;
      setStatus(`Preset selected: ${id}`, 'rgba(255, 255, 255, 0.1)');

      // Reset display
      liveContainer.style.display = 'none';
      liveImg.src = '';
      clearResults();

      // Toggle instant run button for QR mode
      toggleInstantRunButton();

      // Toggle preset groups beneath buttons
      const gDiv = document.getElementById('gesture-presets');
      const oDiv = document.getElementById('object-presets');
      if (selectedMode === 'gesture') {
        if (oDiv) oDiv.style.display = 'none';
        if (gDiv) { gDiv.style.display = 'block'; await loadPresetsGroup('gesture'); }
      } else if (selectedMode === 'object') {
        if (gDiv) gDiv.style.display = 'none';
        if (oDiv) { oDiv.style.display = 'block'; await loadPresetsGroup('object'); }
      } else {
        if (gDiv) gDiv.style.display = 'none';
        if (oDiv) oDiv.style.display = 'none';
      }
    });
  });
  // Initialize Instant Run button visibility on first load
  toggleInstantRunButton();
  if (instantRunButton) {
    instantRunButton.addEventListener('click', async () => {
      try {
        clearResults();
        setStatus('Using existing QR code...', 'rgba(255,255,255,0.1)');

        // Try to fetch the preferred QR generator script from the registry
        let scriptName = null;
        try {
          const p = await fetch('/presets', { cache: 'no-store' });
          const reg = await p.json();
          if (reg && reg.qr && reg.qr.qr_generate) {
            scriptName = reg.qr.qr_generate;
          }
        } catch(e) { /* ignore registry errors */ }

        // Call /instant-run generate for QR
        const genRes = await fetch('/instant-run', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            mode: 'qr',
            action: 'generate',
            scriptName: scriptName
          })
        });
        const genData = await genRes.json();
        if (!genRes.ok) {
          setStatus('Error: ' + (genData.error || 'Failed to initialize QR'), 'rgba(255,0,0,0.2)');
          return;
        }

        // Show live feed
        const streamUrl = (genData.stream_url || '/video_feed') + `?t=${Date.now()}`;
        liveImg.src = streamUrl;
        liveContainer.style.display = 'block';

        // Render QR
        const files = (genData.data && genData.data.qr_codes) ? genData.data.qr_codes : [];
        if (files.length) {
          showQrImages(files);
          addVerifyButtonInstant('qr', genData.data.script_name);
        }
        if (genData.data && genData.data.text) {
          const p = document.createElement('p');
          p.style.color = '#fff';
          p.textContent = genData.data.text;
          statusDiv.insertAdjacentElement('afterend', p);
        }
        setStatus('QR ready. Click Verify (Instant).', 'rgba(0,255,0,0.2)');
      } catch (e) {
        setStatus('Error: ' + e.message, 'rgba(255,0,0,0.2)');
      }
    });
  }

  // -------------------- Actions --------------------
  async function runGenerate() {
    const prompt = promptInput.value.trim();
    if (!prompt) {
      setStatus('Please enter a prompt or choose a preset', 'rgba(255,0,0,0.2)');
      return;
    }
    lastUserPrompt = prompt;

    setStatus('Generating with Claude...', 'rgba(255,255,255,0.1)');
    clearResults();
    runButton.disabled = true;
    if (reuseButton) reuseButton.disabled = true;
    spinner.style.display = 'block';

    try {
      // Always hit /generate first for all modes
      const response = await fetch(`/generate?mode=${encodeURIComponent(selectedMode)}`, {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain; charset=utf-8' },
        body: prompt
      });
      const data = await response.json();
      currentSessionId = data.session_id || null;

      // Show live feed for every mode
      const streamUrl = (data.stream_url || '/video_feed') + `?t=${Date.now()}`;
      liveImg.src = streamUrl;
      liveContainer.style.display = 'block';

      if (!response.ok) {
        setStatus('Error: ' + (data.error || 'Unknown error'), 'rgba(255,0,0,0.2)');
        return;
      }

      if (selectedMode === 'qr') {
        // Render QR results
        const files = (data.data && data.data.qr_codes) ? data.data.qr_codes : [];
        if (files.length) {
          showQrImages(files);
          addVerifyButton('qr');
        }
        if (data.data && data.data.text) {
          const p = document.createElement('p');
          p.style.color = '#fff';
          p.textContent = data.data.text;
          statusDiv.insertAdjacentElement('afterend', p);
        }
        setStatus('QR ready. Click Verify when ready.', 'rgba(0,255,0,0.2)');
        toggleInstantRunButton();
      } else if (selectedMode === 'gesture' || selectedMode === 'object') {
        setStatus('Preparing detector...', 'rgba(255,255,255,0.1)');
        await runValidate(selectedMode, prompt);
      } else {
        setStatus('Done.', 'rgba(0,255,0,0.2)');
      }
    } catch (e) {
      setStatus('Error: ' + e.message, 'rgba(255,0,0,0.2)');
    } finally {
      runButton.disabled = false;
      if (reuseButton) reuseButton.disabled = false;
      toggleInstantRunButton();
      spinner.style.display = 'none';
    }
  }

  async function runValidate(mode, prompt) {
    try {
      setStatus('Validating...', 'rgba(255, 255, 255, 0.1)');
      const payload = {
        prompt: prompt,
        mode: mode,
        session_id: currentSessionId || null
      };
      const res = await fetch('/validate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      // If async job accepted, start polling job status
      if (res.status === 202) {
        const { job_id, poll_url } = await res.json();
        if (window.__jobPoll) clearInterval(window.__jobPoll);
        window.__jobPoll = setInterval(async () => {
          try {
            const r = await fetch(poll_url, { cache: 'no-store' });
            const s = await r.json();
            // Update status banner with phase
            setStatus(`Phase: ${s.phase || 'unknown'}`, 'rgba(255, 255, 255, 0.08)');

            if (s.phase === 'ready') {
              // Switch instructions exactly when the script actually starts running
              const existingInstruction = document.getElementById('live-instruction');
              if (existingInstruction) existingInstruction.remove();
              const instruction = document.createElement('p');
              instruction.id = 'live-instruction';
              instruction.style.color = '#fff';
              instruction.style.marginTop = '0.5rem';
              instruction.textContent = mode === 'gesture'
                ? 'Start your gesture in front of the camera...'
                : (mode === 'object' ? 'Show the object to the camera...' : 'Scanning...');
              statusDiv.insertAdjacentElement('afterend', instruction);
            }

            if (s.phase === 'detected' || s.phase === 'done' || s.phase === 'error') {
              clearInterval(window.__jobPoll);

              // Show results, if any
              if (s.data) {
                const pre = document.createElement('pre');
                pre.style.color = '#ddd';
                pre.style.background = 'rgba(255,255,255,0.06)';
                pre.style.padding = '8px';
                pre.style.borderRadius = '6px';
                pre.textContent = JSON.stringify(s.data, null, 2);
                statusDiv.insertAdjacentElement('afterend', pre);
              }

              // Refresh presets when job is done (new verified may be registered)
              loadPresets();
              if (selectedMode === 'gesture') { loadPresetsGroup('gesture'); }
              if (selectedMode === 'object') { loadPresetsGroup('object'); }

              if (s.phase === 'error') {
                setStatus('Error: detection failed. Please check camera/permissions.', 'rgba(255, 0, 0, 0.2)');
              } else if (s.phase === 'done') {
                const verified = (s.data && typeof s.data.verified !== 'undefined') ? s.data.verified : (s.verified || false);
                if (verified) {
                  setStatus('Verified!', 'rgba(0,255,0,0.25)');
                } else {
                  setStatus('Verification failed.', 'rgba(255,0,0,0.25)');
                }
              } else {
                setStatus('Detected!', 'rgba(0,255,0,0.2)');
              }
            }
          } catch (err) {
            console.error('Job poll error', err);
          }
        }, 1000);
        return; // polling will drive further UI updates
      }

      // Fallback: synchronous response (if server returns 200 with a result)
      const result = await res.json();
      if (res.ok && result.verified) {
        setStatus('Verified!', 'rgba(0, 255, 0, 0.2)');
      } else {
        const reason = result.reason || (result.errors && result.errors[0]) || 'Verification failed';
        setStatus('Error: ' + reason, 'rgba(255, 0, 0, 0.2)');
      }
    } catch (err) {
      setStatus('Error: ' + err.message, 'rgba(255, 0, 0, 0.2)');
    }
  }

  

  // Enter key to submit
  promptInput.addEventListener('keypress', function (e) {
    if (e.key === 'Enter' && !runButton.disabled) {
      runGenerate();
    }
  });
</script>
</body>
</html>